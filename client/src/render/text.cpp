/*
 * Simple Text Renderer Implementation
 * Uses a minimal built-in bitmap font (8x8 pixels per character)
 */

#include "text.h"
#include <GL/glew.h>
#include <stdio.h>
#include <string.h>

// Built-in 8x8 bitmap font (ASCII 32-127)
// Each character is 8 bytes, one byte per row, MSB = leftmost pixel
static const unsigned char font_8x8[96][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ' '
    {0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00}, // '!'
    {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00}, // '"'
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // '#'
    {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00}, // '$'
    {0x00,0x66,0xAC,0xD8,0x36,0x6A,0xCC,0x00}, // '%'
    {0x38,0x6C,0x68,0x76,0xDC,0xCE,0x7B,0x00}, // '&'
    {0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00}, // '''
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // '('
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // ')'
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // '*'
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // '+'
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // ','
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // '-'
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // '.'
    {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00}, // '/'
    {0x7C,0xCE,0xDE,0xF6,0xE6,0xE6,0x7C,0x00}, // '0'
    {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00}, // '1'
    {0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00}, // '2'
    {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // '3'
    {0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00}, // '4'
    {0x7E,0x62,0x60,0x7C,0x06,0x66,0x3C,0x00}, // '5'
    {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00}, // '6'
    {0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00}, // '7'
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00}, // '8'
    {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00}, // '9'
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // ':'
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30}, // ';'
    {0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00}, // '<'
    {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // '='
    {0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00}, // '>'
    {0x3C,0x66,0x0C,0x18,0x18,0x00,0x18,0x00}, // '?'
    {0x7C,0xC6,0xDE,0xDE,0xDC,0xC0,0x7C,0x00}, // '@'
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // 'A'
    {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00}, // 'B'
    {0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00}, // 'C'
    {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00}, // 'D'
    {0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00}, // 'E'
    {0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00}, // 'F'
    {0x3C,0x66,0xC0,0xCE,0xC6,0x66,0x3A,0x00}, // 'G'
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // 'H'
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00}, // 'I'
    {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00}, // 'J'
    {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00}, // 'K'
    {0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00}, // 'L'
    {0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00}, // 'M'
    {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00}, // 'N'
    {0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // 'O'
    {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, // 'P'
    {0x38,0x6C,0xC6,0xC6,0xDA,0xCC,0x76,0x00}, // 'Q'
    {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00}, // 'R'
    {0x3C,0x66,0x70,0x38,0x0E,0x66,0x3C,0x00}, // 'S'
    {0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00}, // 'T'
    {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // 'U'
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // 'V'
    {0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00}, // 'W'
    {0xC6,0x6C,0x38,0x38,0x6C,0xC6,0xC6,0x00}, // 'X'
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00}, // 'Y'
    {0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00}, // 'Z'
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // '['
    {0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00}, // '\'
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // ']'
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, // '^'
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE}, // '_'
    {0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00}, // '`'
    {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00}, // 'a'
    {0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00}, // 'b'
    {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00}, // 'c'
    {0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00}, // 'd'
    {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // 'e'
    {0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00}, // 'f'
    {0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C}, // 'g'
    {0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00}, // 'h'
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // 'i'
    {0x06,0x00,0x0E,0x06,0x06,0x66,0x66,0x3C}, // 'j'
    {0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00}, // 'k'
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // 'l'
    {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // 'm'
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // 'n'
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // 'o'
    {0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78}, // 'p'
    {0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F}, // 'q'
    {0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00}, // 'r'
    {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // 's'
    {0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00}, // 't'
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00}, // 'u'
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // 'v'
    {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // 'w'
    {0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00}, // 'x'
    {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C}, // 'y'
    {0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00}, // 'z'
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // '{'
    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // '|'
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // '}'
    {0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00}, // '~'
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // DEL
};

static GLuint s_font_texture = 0;
static GLuint s_text_shader = 0;
static GLuint s_text_vao = 0;
static GLuint s_text_vbo = 0;

static const char* text_vertex_shader = R"(
#version 330 core
layout(location = 0) in vec2 a_pos;
layout(location = 1) in vec2 a_uv;
out vec2 v_uv;
uniform vec2 u_offset;
uniform vec2 u_scale;
void main() {
    vec2 pos = (a_pos + u_offset) * u_scale * 2.0 - 1.0;
    pos.y = -pos.y;  // Flip Y for screen coords
    gl_Position = vec4(pos, 0.0, 1.0);
    v_uv = a_uv;
}
)";

static const char* text_fragment_shader = R"(
#version 330 core
in vec2 v_uv;
out vec4 frag_color;
uniform sampler2D u_font;
void main() {
    float alpha = texture(u_font, v_uv).r;
    if (alpha < 0.5) discard;
    frag_color = vec4(1.0, 1.0, 1.0, alpha);
}
)";

bool text_init(void) {
    // Create font texture (16x6 grid of 8x8 characters = 128x48 pixels)
    const int CHARS_PER_ROW = 16;
    const int CHAR_ROWS = 6;
    const int TEX_WIDTH = CHARS_PER_ROW * 8;
    const int TEX_HEIGHT = CHAR_ROWS * 8;

    unsigned char* pixels = new unsigned char[TEX_WIDTH * TEX_HEIGHT];
    memset(pixels, 0, TEX_WIDTH * TEX_HEIGHT);

    // Copy font data to texture
    for (int c = 0; c < 96; c++) {
        int cx = (c % CHARS_PER_ROW) * 8;
        int cy = (c / CHARS_PER_ROW) * 8;

        for (int y = 0; y < 8; y++) {
            unsigned char row = font_8x8[c][y];
            for (int x = 0; x < 8; x++) {
                if (row & (0x80 >> x)) {
                    pixels[(cy + y) * TEX_WIDTH + cx + x] = 255;
                }
            }
        }
    }

    glGenTextures(1, &s_font_texture);
    glBindTexture(GL_TEXTURE_2D, s_font_texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, TEX_WIDTH, TEX_HEIGHT, 0, GL_RED, GL_UNSIGNED_BYTE, pixels);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    delete[] pixels;

    // Create shader
    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vs, 1, &text_vertex_shader, NULL);
    glCompileShader(vs);

    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fs, 1, &text_fragment_shader, NULL);
    glCompileShader(fs);

    s_text_shader = glCreateProgram();
    glAttachShader(s_text_shader, vs);
    glAttachShader(s_text_shader, fs);
    glLinkProgram(s_text_shader);

    glDeleteShader(vs);
    glDeleteShader(fs);

    // Create VAO/VBO for quad rendering
    glGenVertexArrays(1, &s_text_vao);
    glGenBuffers(1, &s_text_vbo);

    glBindVertexArray(s_text_vao);
    glBindBuffer(GL_ARRAY_BUFFER, s_text_vbo);
    glBufferData(GL_ARRAY_BUFFER, 6 * 4 * sizeof(float) * 256, NULL, GL_DYNAMIC_DRAW);

    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
    glEnableVertexAttribArray(1);

    glBindVertexArray(0);

    printf("[Text] Font texture and shader initialized\n");
    return true;
}

void text_destroy(void) {
    if (s_text_vao) glDeleteVertexArrays(1, &s_text_vao);
    if (s_text_vbo) glDeleteBuffers(1, &s_text_vbo);
    if (s_text_shader) glDeleteProgram(s_text_shader);
    if (s_font_texture) glDeleteTextures(1, &s_font_texture);
    s_text_vao = s_text_vbo = s_text_shader = s_font_texture = 0;
}

// Internal render function with scale parameter
static void text_render_internal(const char* str, float x, float y, int screen_width, int screen_height, float scale) {
    if (!s_text_shader || !str || !*str) return;

    const float CHAR_WIDTH = 8.0f;
    const float CHAR_HEIGHT = 8.0f;

    // Build vertex data
    float vertices[256 * 6 * 4];  // Max 256 chars, 6 verts per char, 4 floats per vert
    int vertex_count = 0;

    float cx = x;
    float cy = y;

    for (const char* p = str; *p && vertex_count < 256 * 6; p++) {
        char c = *p;
        if (c < 32 || c > 127) c = '?';

        int char_index = c - 32;
        float u0 = (char_index % 16) / 16.0f;
        float v0 = (char_index / 16) / 6.0f;
        float u1 = u0 + 1.0f / 16.0f;
        float v1 = v0 + 1.0f / 6.0f;

        float x0 = cx;
        float y0 = cy;
        float x1 = cx + CHAR_WIDTH * scale;
        float y1 = cy + CHAR_HEIGHT * scale;

        // Two triangles per character
        float quad[6][4] = {
            {x0, y0, u0, v0},
            {x1, y0, u1, v0},
            {x1, y1, u1, v1},
            {x0, y0, u0, v0},
            {x1, y1, u1, v1},
            {x0, y1, u0, v1},
        };

        memcpy(&vertices[vertex_count * 4], quad, sizeof(quad));
        vertex_count += 6;

        cx += CHAR_WIDTH * scale;
    }

    if (vertex_count == 0) return;

    // Upload vertices
    glBindBuffer(GL_ARRAY_BUFFER, s_text_vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, vertex_count * 4 * sizeof(float), vertices);

    // Render
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glUseProgram(s_text_shader);
    glUniform2f(glGetUniformLocation(s_text_shader, "u_offset"), 0, 0);
    glUniform2f(glGetUniformLocation(s_text_shader, "u_scale"), 1.0f / screen_width, 1.0f / screen_height);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, s_font_texture);
    glUniform1i(glGetUniformLocation(s_text_shader, "u_font"), 0);

    glBindVertexArray(s_text_vao);
    glDrawArrays(GL_TRIANGLES, 0, vertex_count);

    glDisable(GL_BLEND);
    glEnable(GL_DEPTH_TEST);
}

// Default scale for panel text (smaller, cleaner look)
static const float DEFAULT_SCALE = 1.25f;

void text_render(const char* str, float x, float y, int screen_width, int screen_height) {
    text_render_internal(str, x, y, screen_width, screen_height, DEFAULT_SCALE);
}

void text_render_right(const char* str, float margin, float y, int screen_width, int screen_height) {
    if (!str) return;
    int len = (int)strlen(str);
    float text_width = len * 8.0f * DEFAULT_SCALE;
    float x = screen_width - text_width - margin;
    text_render_internal(str, x, y, screen_width, screen_height, DEFAULT_SCALE);
}
